{
  "name": "dgr",
  "tagline": "Container build and runtime tool",
  "body": "# dgr - container build and runtime tool\r\n\r\n[![Go Report Card](https://goreportcard.com/badge/github.com/blablacar/dgr)](https://goreportcard.com/report/github.com/blablacar/dgr)\r\n[![GoDoc](https://img.shields.io/badge/godoc-reference-5874B0.svg)](https://godoc.org/github.com/blablacar/dgr)\r\n[![Build Status](https://img.shields.io/travis/blablacar/dgr/master.svg)](https://travis-ci.org/blablacar/dgr)\r\n\r\n<img src=\"https://raw.githubusercontent.com/blablacar/dgr/gh-pages/logo.png\" width=\"300\">\r\n\r\n**dgr** (pronounced \"*digg-er*\") is a command line utility designed to build and to configure at runtime App Containers Images ([ACI](https://github.com/appc/spec/blob/master/spec/aci.md)) and App Container Pods ([POD](https://github.com/appc/spec/blob/master/spec/pods.md)) based on convention over configuration.\r\n\r\ndgr allows you to build generic container images for a service and to configure them at runtime. Therefore you can use the same image for different environments, clusters, or nodes by overriding the appropriate attributes when launching the container.\r\n\r\n_dgr is actively used at blablacar to build and run more than an hundred different aci and pod to [run all platforms](http://blablatech.com/blog/why-and-how-blablacar-went-full-containers)._\r\n\r\n\r\n## Build the ACI once, configure your app at runtime.\r\n\r\ndgr provides various resources to build and configure an ACI:\r\n\r\n- scripts at runlevels (build, prestart...)\r\n- templates and attributes\r\n- static files\r\n- images dependencies\r\n\r\n**Scripts** are executed at the image build, before your container is started and more. See [runlevels](#runlevels) for more information.\r\n\r\n**Templates** and **attributes** are the way dgr deals with environment-specific configurations. **Templates** are stored in the image and resolved at runtime ; **attributes** are inherited from different contexts (aci -> pod -> environment).\r\n\r\n**Static files** are copied to the same path in the container.\r\n\r\n**Image dependencies** are used as defined in [APPC spec](https://github.com/appc/spec/blob/master/spec/aci.md#dependency-matching).\r\n\r\n\r\n![demo](https://raw.githubusercontent.com/blablacar/dgr/gh-pages/aci-dummy.gif)\r\n\r\n\r\n## Commands\r\n\r\n```bash\r\n$ dgr init          # init a sample project\r\n$ dgr build         # build the image\r\n$ dgr clean         # clean the build\r\n$ dgr clean build   # just building, clean is always run before building\r\n$ dgr clean install # clean, build and install aci in the local rkt\r\n$ dgr clean push    # clean, build and push aci to remote storage\r\n$ dgr clean test    # clean, build and test aci\r\n$ dgr install       # use already built aci in target directory to install in rkt\r\n$ dgr push          # use already built aci in target directory to push to remote storage\r\n$ dgr test          # run tests on already built aci\r\n$ dgr try           # run templating only to target/try (experimental)\r\n```\r\n\r\nThere is a lot of different flags on each command. use the helper to see them :\r\n```bash\r\n$ dgr --help\r\n...\r\n$ dgr build --help\r\n...\r\n```\r\n\r\n## Configuration file\r\n\r\n*Global configuration is optional to start as long as you have rkt in $PATH*\r\n\r\ndgr global configuration is a yaml file located at `~/.config/dgr/config.yml`. Home is the home of starting user (the caller user if running with sudo).\r\n\r\n**targetWorkDir** is used to indicate the target work directory where dgr will work to build and create the ACI\r\n**push*** contain informations on how to push the aci/pod to remote storage\r\n**rkt** if you are not using rkt in your path, or want to create specif config\r\n\r\nExample of configuration:\r\n\r\n```yml\r\ntargetWorkDir: /tmp/target      # if you want to use another directory for all builds\r\npush:\r\n  type: maven\r\n  url: https://localhost/nexus\r\n  username: admin\r\n  password: admin\r\nrkt:                            # arguments to rkt. See rkt --help\r\n  path:\r\n  insecureOptions: [image]\r\n  dir: /var/lib/rkt\r\n  localConfig: /etc/rkt\r\n  systemConfig: /usr/lib/rkt\r\n  userConfig:\r\n  trustKeysFromHttps: false\r\n  noStore: false                # can be set by command line\r\n  storeOnly: false              # can be set by command line\r\n```\r\n\r\n\r\n# Building an ACI\r\n\r\n## Initializing a new project\r\n\r\nRun the following commands to initialize a new complete sample project:\r\n\r\n```bash\r\n$ mkdir aci-myapp\r\n$ cd aci-myapp\r\n$ dgr init\r\n```\r\n\r\nIt will generate the following file tree:\r\n\r\n```text\r\n.\r\n|-- attributes\r\n|   `-- attributes.yml                 # Attributes files that will be merged and used to resolve templates\r\n|-- aci-manifest.yml                   # Manifest\r\n|-- templates\r\n|   |-- etc\r\n|   |   |-- templated.tmpl             # template file that will end up at /etc/templated\r\n|   |   `-- templated.tmpl.cfg         # configuration of the targeted file, like user and mode (optional file)\r\n|   `-- header.partial                 # template part that can be included in template files\r\n|-- files\r\n|   `-- dummy                          # Files to be copied to the same location in the target rootfs\r\n|-- runlevels\r\n|   |-- builder\r\n|   |   `-- 10.prepare.sh              # Scripts to be run inside the builder to prepare the aci for build\r\n|   |-- build\r\n|   |   `-- 10.install.sh              # Scripts to be run when building inside aci's rootfs\r\n|   |-- build-late\r\n|   |   `-- 10.build-late.sh           # Scripts to be run when building inside aci's rootfs after the copy of files\r\n|   |-- inherit-build-early\r\n|   |   `-- 10.inherit-build-early.sh  # Scripts stored in ACI and executed while used as a dependency\r\n|   |-- inherit-build-late\r\n|   |   `-- 10.inherit-build-late.sh   # Scripts stored in ACI and executed while used as a dependency\r\n|   |-- prestart-early\r\n|   |   `-- 10.prestart-early.sh       # Scripts to be run when starting ACI before templating\r\n|   `-- prestart-late\r\n|       `-- 10.prestart-late.sh        # Scripts to be run when starting ACI after templating\r\n`-- tests\r\n    |-- dummy.bats                     # Bats tests for this ACI\r\n    `-- wait.sh                        # Script to wait until the service is up before running tests\r\n```\r\n\r\nThis project is already valid which means that you can build it and it will result in a runnable ACI (dgr always adds busybox to the ACI). But you probably want to customize it at this point.\r\n\r\nThe only mandatory information is the `aci-manifest.yml`, with only the aci `name:`. You can remove everything else depending on you needs.  \r\n\r\n## Nice other features\r\n\r\n- builder runlevel with dependencies allow you build a project of any kind (java, php, go, node, ...) and release an aci without anything else than dgr and rkt on the host\r\n- dgr will tell you if you are not using the latest version of a dependency and will tell you which version is the latest\r\n- integrated test system that can be extended to support any kind of test system\r\n- working with [pods](https://github.com/appc/spec/blob/master/spec/pods.md) as a unit during build too\r\n- build application version based on container name\r\n- extract aci version from the version of the software during installation\r\n\r\n## How it's working\r\n<img style=\"margin: 10px 30px 40px 0\" src=\"https://docs.google.com/drawings/d/1bSP6Z2X79xkp6deSNaZ-ShrAPjAPa4bzyjL4df2HLwk/pub?w=850\">\r\n\r\ndgr uses the **builder** information from the **aci-manifest.yml** to construct a rkt stage1. dgr then start rkt with this stage1 on an empty container with the final manifest of your aci (to have dependencies during build).\r\n\r\nInside rkt, the builder isolate the build process inside a **systemd-nspawn** on the builder's rootfs (with mount point on the final aci's rootfs and aci's home) and run the following steps :\r\n- use internal dgr filesystem (busybox, openssl, wget, curl) for the builder if no dependencies (nothing in /usr/bin)\r\n- run **builder** runlevel\r\n- copy **templater** and **inherit** runlevels\r\n- isolate on final rootfs and run **build** runlevels\r\n- copy **prestart**, **attributes**, **files**, **templates**\r\n- isolate on final rootfs and run **build-late** runlevels\r\n\r\n\r\n## Customizing\r\n\r\n### The manifest\r\n\r\nThe dgr manifest looks like a light ACI manifest with extra builder and tester info. \r\ndgr will take the `aci` part and convert it to the format defined in the APPC spec.\r\n\r\nExample of a *aci-manifest.yml*:\r\n\r\n```yaml\r\nname: example.com/myapp:0.1\r\n\r\nbuilder:\r\n  dependencies:\r\n    - example.com/base:1\r\n\r\ntester:\r\n  dependencies:\r\n    - example.com/base:1\r\n    \r\naci:\r\n  dependencies:\r\n    - example.com/base:1\r\n  app:\r\n    exec:\r\n      - /bin/myapp\r\n      - -c\r\n      - /etc/myapp/myapp.cfg\r\n    mountPoints:\r\n      - name: myapp-data\r\n        path: /var/lib/myapp\r\n        readOnly: false\r\n```\r\n\r\nThe **name**, well, is the name of the ACI you are building.\r\n\r\n**builder** node \r\n\r\nUnder the **aci** key, you can add every key that is defined in the [APPC spec](https://github.com/appc/spec/blob/master/spec/aci.md) such as:\r\n\r\n- **exec** which contains the absolute path to the executable your want to run at the start of the ACI and its args.\r\n- **mountPoints** even though you can do it on the command line with recent versions of RKT.\r\n- **isolators**...\r\n\r\nExcept **handlers** that are directly mapped to **prestart** runlevels \r\n\r\n### Runlevels\r\n\r\nThe scripts in `runlevels/build` dir are executed during the build to install in the ACI everything you need. For instance if your dependencies are based on debian, a build script could look like:\r\n\r\n```bash\r\n#!/bin/bash\r\napt-get update\r\napt-get install -y myapp\r\n```\r\n\r\n### Templates\r\n\r\nYou can create templates in your ACI. Templates are stored in the ACI as long as attributes and are resolved at start of the container.\r\n\r\nExample:\r\n\r\n*templates/etc/resolv.conf.tmpl*\r\n\r\n```\r\n{{ range .dns.nameservers -}}\r\nnameserver {{ . }}\r\n{{ end }}\r\n\r\n{{ if .dns.search -}}\r\nsearch {{ range .dns.search }} {{.}} {{end}}\r\n{{end}}\r\n```\r\n\r\n*templates/etc/resolv.conf.tmpl.cfg*\r\n\r\n```\r\nuid: 0\r\ngid: 0\r\nmode: 0644\r\ncheckCmd: /dgr/bin/busybox true\r\n```\r\n\r\n`checkCmd` is a command to run after the templating to check that the configuration is valid or fail container start.\r\n\r\nWhen you have to reuse the same part in multiple templates, you can create a partial template like defined in the [go templating](https://golang.org/pkg/text/template/#hdr-Nested_template_definitions).\r\n\r\n*templates/header.partial*\r\n\r\n```\r\n{{define \"header\"}}\r\nwhatever\r\n{{end}}\r\n```\r\n\r\nand include it in a template:\r\n\r\n```\r\n{{template \"header\" .}}\r\n```\r\n\r\nTemplater provides functions to manipulate data inside the template. Here is the list:\r\n\r\n| Tables    |      Function        |  Description                                                |\r\n|-----------|:---------------------|:------------------------------------------------------------|\r\n| base      | path.Base            |                                                             |\r\n| split     | strings.Split        |                                                             |\r\n| json      | UnmarshalJsonObject  |                                                             |\r\n| jsonArray | UnmarshalJsonArray   |                                                             |\r\n| dir       | path.Dir             |                                                             |\r\n| getenv    | os.Getenv            |                                                             |\r\n| join      | strings.Join         |                                                             |\r\n| datetime  | time.Now             |                                                             |\r\n| toUpper   | strings.ToUpper      |                                                             |\r\n| toLower   | strings.ToLower      |                                                             |\r\n| contains  | strings.Contains     |                                                             |\r\n| replace   | strings.Replace      |                                                             |\r\n| orDef     | orDef                | if first element is nil, use second as default              |\r\n| orDefs    | orDefs               | if first array param is empty use second element to fill it |\r\n| ifOrDef   | ifOrDef              | if first param is not nil, use second, else third           |\r\n\r\nIt also provide all function defined by [gtf project](https://github.com/leekchan/gtf)\r\n\r\n*We can add functions on demand*\r\n\r\n### Attributes\r\n\r\nAll the YAML files in the directory **attributes** are read by dgr. The first node of the YAML has to be \"default\" as it can be overridden in a POD or with a json in the env variable TEMPLATER_OVERRIDE in the cmd line.\r\n\r\n*attributes/resolv.conf.yml*\r\n\r\n```\r\ndefault:\r\n  dns:\r\n    nameservers:\r\n      - \"8.8.8.8\"\r\n      - \"8.8.4.4\"\r\n    search:\r\n      - bla.com\r\n```\r\n\r\n### Prestart\r\n\r\ndgr uses the \"pre-start\" eventHandler of the ACI to customize the ACI rootfs before the run depending on the instance or the environment.\r\nIt resolves at that time the templates so it has all the context needed to do that.\r\nYou can also run custom scripts before (prestart-early) or after (prestart-late) this template resolution. This is useful if you want to initialize a mountpoint with some data before running your app for instance.\r\n\r\n*runlevels/prestart-late/init.sh*\r\n\r\n```bash\r\n#!/bin/bash\r\nset -e\r\n/usr/bin/myapp-init\r\n```\r\n\r\n\r\n\r\n\r\n## Running the aci\r\n\r\nAt this stage you should have a runnable aci. During build, dgr integrated into the aci a prestart that will take care of running templater using `templates` and `attributes`\r\n\r\n### log level\r\nTemplates and default attribute values are integrated into the aci.\r\nAt start you can change log level of prestart scripts and the templater with the environment variable `--set-env=LOG_LEVEL=trace`.\r\ndefault level is info. At `debug`, prestart shell script will activate debug (set -x). At level `trace`, templater will display the result of templating.\r\n\r\n\r\n### Override template's attributes\r\nDefault attributes values integrated in the aci can be overridden by adding a json tree in the environment variable `TEMPLATER_OVERRIDE`\r\n\r\n\r\n### example\r\n```\r\n# sudo rkt --set-env=LOG_LEVEL=trace  --net=host --insecure-options=image run --interactive target/image.aci '--set-env=TEMPLATER_OVERRIDE={\"dns\":{\"nameservers\":[\"10.11.254.253\",\"10.11.254.254\"]}}'\r\n```\r\n\r\n## Troubleshoot\r\ndgr start by default with info log level. You can change this level with the `-L` command line argument.\r\nThe log level is also propagated to all runlevels with the environment variable: **LOG_LEVEL**.\r\n\r\nYou can activate debug on demand by including this code in your scripts:\r\n\r\n```\r\n#!/dgr/bin/busybox sh\r\nset -e\r\n. /dgr/bin/functions.sh\r\nisLevelEnabled \"debug\" && set -x\r\n```\r\nBuild it\r\n```bash\r\n$ dgr -L debug build\r\n```\r\n\r\nYou can also debug the start of your container (prestart, templates) the same way\r\n```bash\r\n$ rkt run --set-env=LOG_LEVEL=debug example.com/my-app\r\n```\r\n\r\n**trace** loglevel, will tell the templater to display the result\r\n\r\n\r\n## Building a POD\r\n\r\nA pod is a group of aci that will build and run together as a single unit.\r\n\r\n### Standard FileTree for POD\r\nTODO\r\n\r\n```bash\r\n├── aci-elasticsearch               # Directory that match the pod app shortname (or name)\r\n│   ├── attributes\r\n│   │   └── attributes.yml          # Attributes file for templating in this ACI\r\n│   ├── files                       # Files to be inserted into this ACI\r\n│   ...\r\n├── pod-manifest.yml            # Pod Manifest\r\n```\r\n\r\n\r\n## Ok, but concretely how should I use it?\r\n\r\n*have a look at the examples/ directory where you can find aci for various distrib*\r\n\r\nDepending on distrib, package manager and what you want to do, you will not work the same way. but globally there is 2 way of building an aci.\r\n\r\n#### Building directly inside the aci\r\nThis is what you will see everywhere else in docker or rkt. You use the **build** and **build-late** runlevels and run commands on the the final rootfs (like apt-get install...)\r\n\r\n#### Building outside of the aci\r\nIf you are using a package manager that support working outside of the target's rootfs or want to build a project, you will work outside of the stage1 directly inside the builder.\r\nFor example if you are buiding an aci for a go project from sources. you will prepare a **builder** with **go** to be able to build the project on the stage1 and put the binary on the aci's rootfs (go is not needed to run the aci).\r\n\r\n*At this step, everybody can build any kind of project, since nothing on the host is used to build the project and the aci.*\r\n\r\nAlso, if you are using a package manager like `pacman` or `emerge`, you can build and install packages on the final **rootfs** without build dependencies nor the package manager.\r\n\r\n#### Note About dependencies\r\n\r\nMost package manager are not design for overlay and are working with a db file for installed software. this means than when your aci have multiple dependencies on the aci, the db files will overlap and the package manager will only see half of package installed.\r\n\r\nAs far as I know only `pacman`, that uses a file tree structure for install package, can support overlay.\r\nIf you are using a debian or similar. I recommand to limit the dependencies to only 2 layers. The base aci with debian minimal fs and one with the application you want.\r\n\r\n\r\n## Comparison with alternatives\r\n\r\n### dgr vs Dockerfile\r\nA Dockerfile is purely configuration, describing the steps to build the container. It does not provide a common way of building containers across a team.\r\nIt does not provide scripts levels, ending with very long bash scripting for the run option in the dockerfile.\r\nIt does not handle configuration, nor at build time nor at runtime and does not support any kind of build outside of the container feature.\r\n\r\n### dgr vs acbuild\r\nacbuild is a command line tools to build ACIs. It is more flexible than Dockerfiles as it can be wrapped by other tools such as Makefiles but like Dockerfiles it doesn't provide a standard way of configuring the images.\r\n\r\n\r\n## Requirement\r\n- [rkt](https://github.com/coreos/rkt) in your `$PATH` or configured in dgr global conf\r\n- being root is required to call rkt\r\n- linux >= 3.18 with overlay filesystem\r\n\r\n\r\n## I want to extend dgr\r\nIf you think your idea can be integrated directly in the core of dgr, please create an issue or a pull request.\r\n\r\nIf you want want to extend the way the **builder** is working (attributes, templates, files, ...), you can create a new **stage1 builder** and replace the internal one with : \r\n```\r\n...\r\nbuilder:\r\n  image: dgrtool.com/aci-builder:1\r\n...\r\n```\r\nYou can do the same for the **tester**.\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}